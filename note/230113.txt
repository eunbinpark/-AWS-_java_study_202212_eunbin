스태틱 안에는 스태틱만 사용가능
멤버 메소드는 주소가 생성되어 있어야 사용가능
<?> : 와일드카드
-와일드카드로 객체를 만들면 자료형이 모호해짐
-그냥 오브젝트 자료형으로 바뀐거라고 생각하면 됨

? 와일드카드 제약
? extends 자료형 : 앞으로 해당 메소드가 리턴될때는 해당 자료형을 상속받은 자료형만 리턴가능
ex) person -> Student Teacher : 가능 Car : 불가능
? super 자료형 : 자료형을 기준으로 상위객체만 가능함
ex) Student -> Sstudent Person : 가능 Teacher : 불가능


리스트
배열은 자료형이지만 리스트는 클래스 객체이다
리스트 내부에 메소드가 전부 정의되어 있어서 그것을 사용하는 것 ex)size
처음 생성할 때 자료형을 설정해주는데 앞쪽에 데이터타입을 정해두면 그 자료형으로 사용 가능하다(원래는 뒤쪽에도 데이터타입 설정하여야 하는데 생략가능)
new ArrayList<>와 같이 어디 담지 않고 혼자 생성할 때는 <>안에 자료형을 꼭 설정해주어야 함 그러나 이렇게 사용할 경우 따로 담은 곳이 없어서 새로 생성할 때마다 다 다른공간에 담기므로 리스트를 사용하는 의미가 없다

처음 생성할 때 제네릭 타입을 사용할 것 같으면
내부의 메소드를 사용할 때 필요한 자료형으로 다운캐스팅 하여 사용가능(잘 안씀)

리스트는 넣는만큼 공간이 유동적으로 늘어남 길이도 계속된 추가 및 삭제에도 유동적

배열에서는 6개의 배열 중 첫번째 인덱스를 삭제하면 갯수는 6개 그대로고 첫번째 인덱스에 null이 들어가는 형식인데 리스트는 첫번째 인덱스를 삭제하면 갯수가 5개로 바뀌고 한칸씩 당겨지며 정렬까지 다시해줌

리스트	순서O 중복O (키-순서대로인덱스-값으로 값 판단)
셋(집합)	순서X 중복X
맵	순서X 키중복X 값중복O 

리스트랑 셋은 상위에 컬렉션이 있고 그 안에 add 메소드가 구현되어있음 그걸 각자 들고와서 오버라이드 해서 사용함
맵은 컬렉션이 아니라 put을 사용함
셋은 값을 꺼내려면 전체 반복을 돌려서 내가 원하는 값이 나올때까지 진행해야함
셋은 키값을 따로 지정하기 않기때문에 넣고 빼고할때 시간이 단축된다 다른 두개에 비해 속도가 빠르다
